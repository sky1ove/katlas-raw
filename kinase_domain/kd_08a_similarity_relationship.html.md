# KD similarity & PSSM similarity


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

``` python
import pandas as pd, numpy as np
import matplotlib.pyplot as plt
from numpy.linalg import norm
from katlas.data import *
from scipy.stats import spearmanr
from katlas.plot import *
from katlas.clustering import *
```

``` python
pspa_t5 = pd.read_parquet('train/pspa_t5.parquet')
```

``` python
df = pspa_t5.copy()
```

``` python
df['0pY'].value_counts()
```

    0pY
    0.0    290
    1.0     78
    Name: count, dtype: int64

``` python
st = df[df['0pY']==0].copy()
tyr = df[df['0pY']==1].copy()
```

``` python
def euclidean_dist(u, v):
    return norm(u - v)
```

``` python
def get_dist(df):
    df =df.copy()
    t5_cols = df.columns[df.columns.str.startswith('T5')]
    pssm_cols = df.columns[~df.columns.str.startswith('T5')]
    D_pssm = get_1d_js_parallel(df[pssm_cols])
    D_t5 = get_1d_distance_parallel(df[t5_cols],func_flat=euclidean_dist)
    return D_t5,D_pssm
```

``` python
D_t5,D_pssm= get_dist(st)
```

      0%|          | 0/41905 [00:00<?, ?it/s]

      0%|          | 0/41905 [00:00<?, ?it/s]

``` python
D_t5_y,D_pssm_y= get_dist(tyr)
```

      0%|          | 0/3003 [00:00<?, ?it/s]

      0%|          | 0/3003 [00:00<?, ?it/s]

``` python
def plot_scatter(x, y,line=None):
    plt.figure(figsize=(4,3), dpi=300)
    plt.scatter(x, y, s=3, alpha=0.3)

    # labels
    plt.xlabel("Euclidean distance in T5 embeddings of KDs")
    plt.ylabel("JS divergence in PSSMs")

    # calculate Spearman correlation
    rho, pval = spearmanr(x, y)

    # annotate Spearman correlation coefficient on the plot
    plt.text(0.95, 0.95, f"Spearman ρ = {rho:.3f}", 
             ha="right", va="top", transform=plt.gca().transAxes,
             fontsize=10, bbox=dict(facecolor="white", alpha=0.6, edgecolor="none"))

    if line is not None: plt.axvline(x=line, color="darkred", alpha=0.7,linestyle="--", linewidth=1)
    plt.tight_layout()
```

``` python
plot_scatter(D_t5,D_pssm,line=0.25)
plt.title('PSSM distance vs. KD distance')
save_svg('fig/JSD_PSSM_vs_KD_distance.svg')
```

![](kd_08a_similarity_relationship_files/figure-commonmark/cell-12-output-1.png)

``` python
plot_scatter(D_t5_y,D_pssm_y,line=0.25)
```

![](kd_08a_similarity_relationship_files/figure-commonmark/cell-13-output-1.png)

## Distance in all kd

``` python
df  = Data.get_kd_uniprot()
```

``` python
df = df[df.active_D1_D2==1].reset_index(drop=True)
```

``` python
df['in_pspa']  = df.kd_ID.isin(pspa_t5.index).astype(int)
# df['in_cddm']  = df.kd_ID.isin(cddm_t5.index).astype(int)
```

``` python
df.in_pspa.value_counts()
```

    in_pspa
    0    3841
    1     368
    Name: count, dtype: int64

``` python
# from katlas.feature import *

# t5 = get_t5(df,col='kd_seq')

# t5.index=df.kd_ID

# t5 = t5.astype('float64')

# t5.to_parquet('out/uniprot_kd_t5.parquet')
```

``` python
t5_df = pd.read_parquet('raw/t5_kd.parquet')
```

``` python
def find_close_negatives(df: pd.DataFrame,
                         label_series,
                         threshold: float = 0.25,
                         return_all: bool = False) -> pd.DataFrame:
    """
    For each negative (label_col==0), find the nearest positive (label_col==1)
    by Euclidean distance over `features`, and mark whether it's within `threshold`.

    Returns a DataFrame indexed by the negatives' index with columns:
      - closest_pos_index
      - closest_dist
      - within_threshold (bool)
    If `return_all=False`, only rows within threshold are returned.
    """

    # Extract arrays
    mask_pos = label_series.eq(1).to_numpy()
    mask_neg = ~mask_pos

    X_pos = df.loc[mask_pos].to_numpy(dtype=float, copy=False)
    X_neg = df.loc[mask_neg].to_numpy(dtype=float, copy=False)

    # Handle edge cases
    if X_pos.size == 0 or X_neg.size == 0:
        out = pd.DataFrame(columns=["closest_pos_index", "closest_dist", "within_threshold"],
                           index=df.index[mask_neg])
        return out if return_all else out.iloc[0:0]

    # Pairwise squared distances: ||a-b||^2 = ||a||^2 + ||b||^2 - 2 a·b
    sq_pos = np.einsum('ij,ij->i', X_pos, X_pos)            # (P,)
    sq_neg = np.einsum('ij,ij->i', X_neg, X_neg)            # (N,)
    D2 = sq_neg[:, None] + sq_pos[None, :] - 2.0 * (X_neg @ X_pos.T)
    np.maximum(D2, 0.0, out=D2)                             # numerical safety
    # Nearest positive for each negative
    idx_min = D2.argmin(axis=1)                             # (N,)
    dmin = np.sqrt(D2[np.arange(D2.shape[0]), idx_min])     # (N,)

    # Map back to indices
    pos_index = df.index[mask_pos].to_numpy()
    neg_index = df.index[mask_neg].to_numpy()
    closest_pos_index = pos_index[idx_min]

    out = pd.DataFrame({
        "closest_pos_index": closest_pos_index,
        "closest_dist": dmin,
        "within_threshold": dmin <= threshold,
    }, index=neg_index)

    return out if return_all else out[out["within_threshold"]]
```

``` python
results_pspa = find_close_negatives(t5_df, label_series=df.in_pspa,
                                   threshold=0.25, return_all=True)
```

``` python
results_pspa.to_parquet('raw/kd_similar_pspa.parquet')
```

``` python
results_pspa[results_pspa.within_threshold].sort_values('closest_dist')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">closest_pos_index</th>
<th data-quarto-table-cell-role="th">closest_dist</th>
<th data-quarto-table-cell-role="th">within_threshold</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">A4K2Y1_STK4_CHLAE_KD1</td>
<td>Q13043_STK4_HUMAN_KD1</td>
<td>0.000000</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">A4K2T0_STK4_MACMU_KD1</td>
<td>Q13043_STK4_HUMAN_KD1</td>
<td>0.000000</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Q5RCY1_UHMK1_PONAB_KD1</td>
<td>Q8TAS1_UHMK1_HUMAN_KD1</td>
<td>0.000000</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Q5RCC4_KCC2A_PONAB_KD1</td>
<td>Q9UQM7_KCC2A_HUMAN_KD1</td>
<td>0.000000</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">A2VDU3_M3K7_BOVIN_KD1</td>
<td>O43318_M3K7_HUMAN_KD1</td>
<td>0.000000</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">O08605_MKNK1_MOUSE_KD1</td>
<td>Q9HBH9_MKNK2_HUMAN_KD1</td>
<td>0.248701</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">P87253_KPC1_NEUCR_KD1</td>
<td>Q04759_KPCT_HUMAN_KD1</td>
<td>0.249016</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Q9W739_CDK1_RANDY_KD1</td>
<td>P06493_CDK1_HUMAN_KD1</td>
<td>0.249479</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Q99PW4_PRPKB_MOUSE_KD1</td>
<td>Q96S44_PRPK_HUMAN_KD1</td>
<td>0.249534</td>
<td>True</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Q8AYG3_TTK_DANRE_KD1</td>
<td>P33981_TTK_HUMAN_KD1</td>
<td>0.249601</td>
<td>True</td>
</tr>
</tbody>
</table>

<p>1230 rows × 3 columns</p>
</div>
